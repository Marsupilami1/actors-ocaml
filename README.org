#+TITLE: actors-ocaml
#+DESCRIPTION: An actor library for OCaml 5
#+AUTHOR: Martin Andrieux

* Compiling the project
You can compile ~actors-ocaml~ and run the test executable simply by running:
#+begin_src bash
$ dune build
$ dune test
#+end_src

* Write a program using actors
Let's write a simple programs to calculate the fibonacci numbers.

First, we want a method acting like a function ~fib : int -> int~. To do this, we create the following type:
#+begin_src ocaml
type message = Fib of int
#+end_src

Objects of type ~message~ will be sent to the actor. It mean "The actor have a function Fib, which takes an integer"

We cannot (for the moment) specify a return type for the function ~fib~ (see the IDEA below)

Once declared, we can define the ~fib~ function:
#+begin_src ocaml
let methods self = function
  | Fib n ->
    if n < 2 then n else begin
      let p1 = Actor.send self (Fib (n - 1)) in
      let p2 = Actor.send self (Fib (n - 2)) in
      Promise.get p1 + Promise.get p2
    end
#+end_src

And we can finally create the actor with ~Actor.create~ (we use () because we do not need any memory):
#+begin_src ocaml
let actor = Actor.create () methods
#+end_src

The main function could look like:
#+begin_src ocaml
let _ =
  Actor.run actor;
  let n = 6 in
  let p = Actor.send actor (Fib n) in
  Printf.printf "fib(%d) = %d\n" n @@ Promise.wait_and_get p
#+end_src


* Explanations
** Promises
*** Type
Promise are boxes where you can write only once, so something like
#+begin_src ocaml
type 'a promise = 'a option ref
#+end_src

For more readability, we define a new type (not exported anyway):
#+begin_src ocaml
type 'a status = Empty | Filled of 'a
type 'a t = 'a status ref
#+end_src

This type is fine for simple programs, but waiting processes have no way to know when the promise is filled.
So we add a list of hooks to the empty future. These hooks will be executed when the promise it filled.
Thanks to this, the scheduler can add a hook to a promise to put a waiting process back in the queue.

The real ~status~ type is:
#+begin_src ocaml
type 'a status =
  | Empty of ('a -> unit) list
  | Filled of 'a
#+end_src
As you can see, the hook takes a function ~a -> unit~, so it will receive the value of the future in argument.
This is useful to define functions such as ~fmap~ and ~join~ (See ~Promise.Infix~).

*** Creating and writing
You can create a promise with the ~create~ function, and fill it with ~fill~.

Trying to fill in the same promise twice raises a ~Promise__Multiple_Write~ error.

*** Reading
You have two ways to read the value from a promise:
- ~wait_and_get~ is blocking, so you can use it if someone else is doing the computation in /parallel/
- ~get~ will throw the effect ~NotReady p~ if the value is not available. It can then be handled by a scheduler to compute the value /concurently/.

In both case, if the value will be returned if it is available

** Actors
*** Type
An actor is (for the moment) only a bunch of functions, a mailbox and a scheduler, it's definition is:

#+begin_src ocaml
type ('m, 's, 'a) t = {
  (* message and promise to write the result in *)
  mail_box : ('s * 'a Promise.t) Queue.t;
  (* mutex for the mailbox *)
  mail_mutex : Mutex.t;
  (* list of processes running concurently *)
  processes : 'a process Queue.t;
  (* local memory *)
  memory : 'm;
  (* different methods of the actor *)
  (* represented by one unique function because of the sum type *)
  methods : ('m, 's, 'a) t -> 's -> 'a
}
#+end_src

It is parameterized on ~m~, ~s~ and ~a~.
- ~m~ is the type of the shared memory
- ~s~ is the type of messages
- ~a~ is the return type of the methods

It is not possible at this time to have multiple return types (you can use a sum type if you need it).

**** IDEA Better type for messages
A better solution would be to consider ~a s~ : a method which returns something of type ~a~. It should be possible with a GADT like so:
#+begin_src ocaml
type 'a message =
  | Fib : int -> int message
  | Elem : 'a list * 'a -> bool message
  (* plus other methods... *)
#+end_src

But I don't know if it's possible to have an higher-kinded type parameter in OCaml. In Haskell I would write an ~Actor~ of kind ~* -> (* -> *) -> *~ where ~(* -> *)~ is the "type" of messages.

*** Creation
To create an actor, you only need to specify its methods and its shared memory.
A method is a function which takes an actor (~self~) and a message.

Do not use ~Promise.wait_and_get~ on a promise obtained by self, you'll get stuck on a value that will never be calculated.
Maybe this will be ensured by the type system in the future.

*** Execution
To run an actor, just call the ~run~ function on it.
It will spawn a new thread and run the scheduler.


* Exemples
** Memoized Fibonacci
#+begin_src ocaml
open Actorsocaml

type message =
  | Fib of int

let memory = Array.make 20000 None

let methods self = function
  | Fib n ->
    let m = Actor.memory self in
    if m.(n) <> None then
      Option.get m.(n)
    else if n < 2 then n else begin
      (* The order is important *)
      let p1 = Actor.send self (Fib (n - 1)) in
      let v1 = Promise.get p1 in
      let p2 = Actor.send self (Fib (n - 2)) in
      let v2 = Promise.get p2 in
      let res = v1 + v2 in
      m.(n) <- Some res; res
    end

let actor = Actor.create memory methods

let _ =
  Actor.run actor;
  let n = 42 in
  let p = Actor.send actor (Fib n) in
  Printf.printf "fib(%d) = %d\n" n @@ Promise.wait_and_get p
#+end_src
