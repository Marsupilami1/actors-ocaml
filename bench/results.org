#+title: Bench results

* Tested on
- CPU: 11th Gen Intel(R) Core(TM) i7-1165G7 @ 2.80GHz (8 cores)
- RAM: 8 GB

* Ackerman(3, 4)
- Latencies for 500 iterations of "Await":
  Await:  1.73 WALL ( 5.48 usr +  0.09 sys =  5.57 CPU) @ 89.83/s (n=500)
- Latencies for 1000 iterations of "EIO":
  EIO:  2.91 WALL ( 2.90 usr +  0.00 sys =  2.90 CPU) @ 344.42/s (n=1000)
- Latencies for 1000000 iterations of "Forward":
  Forward:  2.93 WALL ( 4.64 usr +  1.17 sys =  5.81 CPU) @ 172120.48/s (n=1000000)

|         | Rate     |   Await |    EIO | Forward |
|---------+----------+---------+--------+---------|
| Await   | 89.8/s   |       X |   -74% |   -100% |
| EIO     | 344/s    |    283% |      X |   -100% |
| Forward | 172120/s | 191507% | 49875% |       X |

* Factorial
- Latencies for 10000 iterations of "term fut":
  term fut:  1.29 WALL ( 1.28 usr +  0.00 sys =  1.29 CPU) @ 7781.18/s (n=10000)
- Latencies for 10000 iterations of "basic fut":
  basic fut:  1.11 WALL ( 1.77 usr +  0.08 sys =  1.86 CPU) @ 5388.69/s (n=10000)
- Latencies for 1000 iterations of "monad fut":
  monad fut:  0.61 WALL ( 1.30 usr +  0.07 sys =  1.37 CPU) @ 730.11/s (n=1000)
- Latencies for 1000 iterations of "fmap fut":
  fmap fut:  0.24 WALL ( 0.48 usr +  0.03 sys =  0.51 CPU) @ 1957.33/s (n=1000)
- Latencies for 10000 iterations of "basic eio":
  basic eio:  1.38 WALL ( 2.10 usr +  0.11 sys =  2.21 CPU) @ 4520.23/s (n=10000)

|           | Rate   | monad fut | fmap fut | basic eio | basic fut | term fut |
|----------+--------+-----------+----------+-----------+-----------+---------- |
| monad fut | 730/s  |         X |     -63% |      -84% |      -86% |     -91% |
| fmap fut  | 1957/s |      168% |        X |      -57% |      -64% |     -75% |
| basic eio | 4520/s |      519% |     131% |         X |      -16% |     -42% |
| basic fut | 5389/s |      638% |     175% |       19% |         X |     -31% |
| term fut  | 7781/s |      966% |     298% |       72% |       44% |        X |

* Linked list (Be careful, results are in iter/s _OR_ s/iter)
System time is significant here.
Can not allocate more than 127 Domains (so max 128 with the main domain).
** Basic
*** 1000 nodes
Latencies for 100 iterations of "Linked list":
Linked list:  1.61 WALL ( 3.72 usr +  0.82 sys =  4.54 CPU) @ 22.04/s (n=100)
              Rate Linked list
Linked list 22.0/s          --

*** 10_000 nodes
Latencies for 10 iterations of "Linked list":
Linked list:  5.46 WALL (20.04 usr +  1.28 sys = 21.32 CPU) @  0.47/s (n=10)
            s/iter Linked list
Linked list   2.13          --

** Tail recursive
*** 1000 nodes
Latencies for 100 iterations of "Linked list":
Linked list:  1.66 WALL ( 3.63 usr +  0.96 sys =  4.59 CPU) @ 21.79/s (n=100)
              Rate Linked list
Linked list 21.8/s          --

*** 1000 nodes forward
Latencies for 100 iterations of "Linked list":
Linked list:  1.06 WALL ( 2.21 usr +  0.64 sys =  2.85 CPU) @ 35.11/s (n=100)
              Rate Linked list
Linked list 35.1/s          --

*** 10_000 nodes
Latencies for 10 iterations of "Linked list":
Linked list:  5.46 WALL (19.52 usr +  1.22 sys = 20.75 CPU) @  0.48/s (n=10)
            s/iter Linked list
Linked list   2.07          --

*** 10_000 nodes forward
Latencies for 10 iterations of "Linked list":
Linked list:  4.01 WALL (14.12 usr +  0.65 sys = 14.77 CPU) @  0.68/s (n=10)
            s/iter Linked list
Linked list   1.48          --

* Broadcast
We consider a complete graph of size ~graph_size~ and a number of hops ~hops~.
When a node receive a message ~n~, it sends ~n - 1~ to all its neighbors.
** Basic style: 10 nodes, 5 hops (~ 10^5 messages)
Latencies for 10 iterations of "Broadcast Basic":
Broadcast Basic:  7.47 WALL (15.94 usr +  4.56 sys = 20.49 CPU) @  0.49/s (n=10)
                s/iter Broadcast Basic
Broadcast Basic   2.05              --

** Monadic style: 10 nodes, 5 hops (~ 10^5 messages)
Latencies for 10 iterations of "Broadcast Monad":
Broadcast Monad:  7.45 WALL ( 2.88 usr +  6.19 sys =  9.07 CPU) @  1.10/s (n=10)
                  Rate Broadcast Monad
Broadcast Monad 1.10/s              --

* Matmul
Recursive matrix product, actors split the matrix, send sub computations to other actors, and merge the result.

** Parallel
if size <= 64, stop parallelism
*** n = 128
Latencies for 100 iterations of "Mat Mul":
Mat Mul:  3.06 WALL (13.53 usr +  0.06 sys = 13.58 CPU) @  7.36/s (n=100)
          Rate Mat Mul
Mat Mul 7.36/s      --
*** n = 256
Latencies for 40 iterations of "Mat Mul":
Mat Mul:  7.92 WALL (51.73 usr +  0.09 sys = 51.81 CPU) @  0.77/s (n=40)
        s/iter Mat Mul
Mat Mul   1.30      --
*** n = 512
Latencies for 5 iterations of "Mat Mul":
Mat Mul:  7.53 WALL (49.86 usr +  0.08 sys = 49.94 CPU) @  0.10/s (n=5)
        s/iter Mat Mul
Mat Mul   9.99      --
** Actor but no recursive calls
*** n = 128
Latencies for 40 iterations of "Mat Mul":
Mat Mul:  3.60 WALL ( 8.55 usr +  0.18 sys =  8.72 CPU) @  4.59/s (n=40)
          Rate Mat Mul
Mat Mul 4.59/s      --
*** n = 256
Latencies for 5 iterations of "Mat Mul":
Mat Mul:  3.28 WALL ( 7.88 usr +  0.12 sys =  8.01 CPU) @  0.62/s (n=5)
        s/iter Mat Mul
Mat Mul   1.60      --
** Classical
*** n = 128
Latencies for 40 iterations of "Mat Mul":
Mat Mul:  3.60 WALL ( 8.55 usr +  0.18 sys =  8.72 CPU) @  4.59/s (n=40)
          Rate Mat Mul
Mat Mul 4.59/s      --
*** n = 256
Latencies for 5 iterations of "Mat Mul":
Mat Mul:  3.11 WALL ( 4.85 usr +  0.18 sys =  5.03 CPU) @  0.99/s (n=5)
        s/iter Mat Mul
Mat Mul   1.01      --
*** n = 512
Latencies for 5 iterations of "Mat Mul":
Mat Mul: 26.27 WALL (40.51 usr +  1.74 sys = 42.25 CPU) @  0.12/s (n=5)
        s/iter Mat Mul
Mat Mul   8.45      --
